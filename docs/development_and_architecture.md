## Overview

The project is comprised of seven services:

- Hasura GraphQL Engine
- Node.js API
- Mock Server
- Vue.js Front-End
- Postgres Database
- Prometheus
- OpenFaaS with handler examples in
  - Node ***(JWT Auth Sign-up + Login Hasura Actions pre-made)***
  - Python 
  - Ruby
  - C#
  - Go
  - PHP
  - Java

?> **Note:** Garden allows defining environment variables in two ways. One is directly as a YAML key in the project-level `garden.yml`, the other is as `garden.<env-name>.env` files. The `garden.env` file is a base-level configuration, with more specific ones such as `garden.remote.env` being patched over the base. We have defined some environment variables we share between Hasura's configuration and some Node auth code in our Actions OpenFaaS handlers there. [You can read more about Garden variables and templating here](https://github.com/garden-io/garden/blob/master/docs/guides/variables-and-templating.md)

## Hasura GraphQL Engine

### http://hasura.local.app.garden

This service is the core of the stack and provides the following:

- Web Console
  - Visual table-editor for architecting data models and schema design
  - Data browser for viewing and querying table records
  - Authorization and Permissions system
  - Entity associations and relationships
  - GraphiQL (An in-browser IDE for exploring GraphQL)
- Autogenerated GraphQL API
  - CRUD methods
  - Aggregation queries
  - Filtering, sorting, pagination
- Administrative REST API for managing the engine instance
  - Schema/Metadata operations
  - Health check
  - PG Dump interface
  - Configuration
- Schema management through versioned migration and seed files

## Node.js API

### http://api.local.app.garden

This service provides authentication functionality for Hasura, as well as business logic that is necessary for operations outside of the scope of the basic CRUD and aggregations methods Hasura provides. Useful for actions like:

- Sending emails or SMS messages
- Processing payments
- Running scheduled jobs
- Complex multi-step mutations or input validation

## Mock Server

### http://mocks.local.app.garden

This service is a Node.js + Apollo GraphQL API that is pre-configured to automatically generate realistic mock values via introspection of the Hasura instance. This allows you to send GraphQL requests to it that mirror the requests you would normally send Hasura, and receive responses with values that conform to general expected shape and value. Useful for wiring up calls to Hasura from other services early on without writing seed data.

The mock data is provided by extending Apollo Server's built-in `mock` configuration option with some custom resolvers using `Faker.js`. These mock responses can be customized and configured by editting the `defaultMocks`and `customMocks` variables located in `app/services/mock-server/mocks.js`:

```js
// Default GraphQL scalars and Hasura/Postgres database types
const defaultMocks = {
  Int: () => faker.random.number({ min: 0, max: 100 }),
  String: () => faker.random.words(5),
  numeric: () => faker.random.number({ min: 0, max: 100, precision: 0.01 }),
  timestamptz: () => {
    const betweenLastWeekAndThisWeek = faker.random.number({
      min: -7,
      max: 7
    })
    return faker.date.recent(betweenLastWeekAndThisWeek)
  }
}

// User-defined data types
const customMocks = {
  event: () => ({
    photo_url: () => faker.random.image()
  })
}
```

> **Note:** The mock server's GraphQL API can be validly queried on any sub-path of the service. It is recommended that you mimic the URL scheme of Hasura's GraphQL API so that intention remains clear. <br> http://mocks.local.app.garden/v1/graphql (external access) <br> http://mocks/v1/graphql (in-cluster access)

## Vue.js Front-End

### http://frontend.local.app.garden

This service is a standard Vue web app. It has been configured with Garden to run differently based on it's execution environment though.

When running locally or against a staging cluster, it will use `npm run serve` as the serving mechanism and is exposed on port `8080` (by default). In a production environment, the service has been configured to instead run the build process with `npm run build` and then serve the built assets with Nginx.

This is achieved through templated logic in the service's `garden.yaml` and two separate Dockerfiles.

```yaml
kind: Module
description: Vue frontend app
name: frontend
type: container
dockerfile: "${environment.name == 'production' ? 'Dockerfile.prod' : 'Dockerfile.dev' }"
---
services:
  - name: frontend
    ports:
      - name: http
        # Production: Nginx serves on port 80
        # Development: "npm run serve" serves on port 8080
        containerPort: "${environment.name == 'production' ? 80 : 8080 }"
```

```dockerfile
# Dockerfile.dev

FROM node:10-alpine
WORKDIR /app
ADD package.json package-lock.json /app/
RUN npm install
ADD . /app
CMD ["npm", "run", "serve"]
```

```dockerfile
# Dockerfile.prod

# build stage
FROM node:lts-alpine as build-stage
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# production stage
FROM nginx:stable-alpine as production-stage
COPY --from=build-stage /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## Postgres Database

A container image of Postgres that Hasura has been pre-configured to connect to.

## OpenFaaS (faas-netes)

A Serverless Function/Container framework. OpenFaaS allows you to deploy any single function, executable binary, or custom Docker container (similar to Google Cloud Run, except it supports more than just containers).

It also sets up Prometheus for collecting metrics from the function handlers. Each function/container will automatically be provisioned an HTTP Ingress endpoint using NGINX. Advanced functionality such as streaming methods over NATS are also available.